c++ define宏定义使用续行符/的时候后面不能加额外字符，要/后直接回车不然会导致无法续行

编译器设置：

当使用Visual Studio时要注意下载Windows SDK的版本：Windows SDK 版本与 Windows OS 版本相对应。 C11 和 C17 支持需要 Windows SDK 10.0.20348.0（版本 2104）或更高版本

- delete 不需要判断指针是否为空，汇编代码得出：会在删除之前判断是否是空指针
- 内存对齐会导致结构或类的内存分配出乎意料，结构或类中不同类型的声明顺序会导致内存分配不一致，#pragma pack(对齐模数) 用来改变对齐模数

1. 成员变量大都以m_开头
2. 在64位系统中所有指针的空间大小都8个字节，32位系统则是4个字节
3. 闭包：函数调用了外部的局部变量，就称为闭包
4. 悬挂（空悬、垂悬）指针：指针指向的内存段被释放或回收，但指向该段内存的指针没有改变
5. 哑函数：无实际

#include ""和<>区别：

若 #include "" 查找成功，则遮蔽 #include <> 所能找到的同名文件；否则再按照 #include <> 的方式查找文件。另外标准库头文件都放在 #include <> 所查找的位置。一般来说 #include <> 的查找位置是标准库头文件所在目录， #include "" 的查找位置是当前源文件所在目录

struct 和 class 区别：

- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承
- class 可以使用模板，而 struct 不能

array new 和 array delete 需要搭配使用：

若使用delete删除array new，的确对释放数组中的元素，但是会导致只会调用第一个元素的析构函数，若数组元素中存在动态内存分配，则会导致对象占用的堆空间为被释放造成内存泄露

拷贝初始化：将一个已有的对象拷贝到正在创建的对象，如果需要的话还需要进行类型转换

直接初始化：在对象初始化时，通过括号给对象提供一定的参数，并且要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

Lambda<C11>：

like：`[capture list] (params list) mutable exception-> return type { function body }`

1. capture list：捕获外部变量列表
2. params list：形参列表
3. mutable指示符：用来说用是否可以修改捕获的变量
4. exception：异常设定
5. return type：返回类型
6. function body：函数体

const:

1. const和constexpr<C11特性>区别：const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。
2. const 添加于函数末尾：表明该函数只用于读取数据，不能在函数中修改任何数据
3. const 常量必须被初始化，或在类初始化列表中初始化。
4. 常量指针：const修饰指针，指针指向可以更改，指针指向的值不可以更改 形如：int a=10;int b=10;const int * p1=&a;p1=&b;
5. 指针常量：const修饰常量，指针指向不能修改，指针指向的值可以修改 形如：int a=10;int * const p2=&a;*p2=100;
6. const既修饰指针又修饰常量：既不能修改指向的值也不能修改指针指向 形如：int a=10;const int* const p3=&a;
7. const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。

引用和指针区别：

- 没有空引用，但有空指针
- 引用一旦初始化，就不能被其他对象引用（从一而终），但指针可以指向另一个对象
- 引用必须创建时初始化，指针不必

BIG Three原则：

(class with point member) 拷贝构造 拷贝赋值 析构函数如果显式定义“析构函数、复制构造函数、复制赋值运算符”其中一个，那么其他两个也需要同时显式定义

当需要显式定义析构函数时，类中会有动态申请的内存空间需要释放->类中就会有指针类型，当有指针类型时，使用编译器自动生成的赋值运算符、复制构造函数会导致浅拷贝甚至是内存泄漏，故需要开发者显式实现

内联函数：

1. 为了避免调用方法时开辟方法栈而产生的消耗，使用inline关键字，建议编译器将方法的函数体插入调用函数的地方，从而避免调用方法的开销，（函数代码较长，函数内有循环..等复杂函数不建议使用内联）
2. 在类体内部定义的函数加 inline 关键字成为内联函数
3. 希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字

this指针：

1. this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。（this 是一个指针，要用->来访问成员变量或成员函数）
2. this 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值
3. this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
4. this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
5. 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用
6. this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
7. 成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。
8. 编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

static关键字

1. static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。静态成员变量必须初始化，而且只能在类体外进行
2. static 成员变量既可以通过对象<类指针>来访问，也可以通过类来访问
3. static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问
4. 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。
5. 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

友元：

1. 友元提供了除了可以通过类成员方法访问类的私有对象的另一种方式<友元不可传递，B是A友元，C是B友元 但 不能说C是A 的友元 破坏封装 谨慎使用>
2. 友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象
    - 在一个类中使用friend关键字声明友元方法

friend void printName(const FriendTest& friendTest);

---

- 实现友元方法：该方法不属于任何类，可以通过FriendTest访问FriendTest的私有属性

void printName(const FriendTest& test) {

}

---

1. 友元类：
    - 声明一个类为另一个类的友元类

friend class a;

---

- 编写友元类，友元类中可访问另一个类的私有属性

void printName(const FriendTest& test);

---

箭头运算符->、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载

构造函数初始化列表：Student::Student(int id) :m_id(id)

析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。

C++继承方式：public、protected、private 指定继承方式

**1. public继承方式 2. ◦ 基类中所有 public 成员在派生类中为 public 属性； ◦ 基类中所有 protected 成员在派生类中为 protected 属性； ◦ 基类中所有 private 成员在派生类中不能使用。 3.  protected继承方式 4. ◦ 基类中的所有 public 成员在派生类中为 protected 属性； ◦ 基类中的所有 protected 成员在派生类中为 protected 属性； ◦ 基类中的所有 private 成员在派生类中不能使用。 5.  private继承方式 6. ◦ 基类中的所有 public 成员在派生类中均为 private 属性； ◦ 基类中的所有 protected 成员在派生类中均为 private 属性； ◦ 基类中的所有 private 成员在派生类中不能使用。**

using 改变基类访问权限：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问。

基类成员函数和派生类成员函数不会构成重载，如果派生类有基类同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。

基类构造函数调用：将基类构造函数的调用放在参数初始化列表,派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码）

Student::Student(char*name,intage,floatscore):People(name,age),m_score(score){}

Student::Student(char*name,intage,floatscore):People("小明",16),m_score(score){}

---

定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么

编译失败

继承中的析构函数调用顺序与构造函数相反，例：A->B->C 构造函数调用顺序：A->B->C ，析构函数调用顺序：C->B->A

多继承下构造函数的调用顺序与声明派生类时基类出现的顺序相同，析构函数依然与构造函数调用顺序相反（c++不建议多继承）

虚继承：virtual关键字,为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员：如果a-虚继承->b and c->d(菱形继承)  a有一个x字段，可避免名称冲突，但如果 b 和c 自己也都有个自己的x字段，则虚继承依然会产生名称冲突

虚基类的构造函数需要最终类调用，其他继承类则由定义顺序决定

std::string会在堆上分配内存，但对于字符串长度小于16（MSVC下为16，因编译器不同而不同）的字符特殊处理在栈上分配

[Q&A](https://www.notion.so/Q-A-49f721d082254b4db07cab3ffeaf388a?pvs=21)

[VersionFeatures](https://www.notion.so/VersionFeatures-7d956112364c4605ab86a7a277bf6848?pvs=21)

[侯捷课程](https://www.notion.so/d31637cbba7446ce896ba533bda4e2d9?pvs=21)

当调用一个函数返回的string时，如果该函数的返回值未被变量接收，则会产生一个临时变量，这个临时变量的生命周期到这个表达式结束而结束，如果有变量接收则不会产生临时变量，临时变量只能通过 const **引用**来指向，因此是不可修改的。

## QA
1. C++程序执行报错"error while loading shared libraries: xxx.so.0:cannot open shared object file: No such file or directory"：检查是否连接了库，若无效，尝试将库所在文件夹添加到/etc/ld.so.conf中，使用ldconfig –v更新配置
2. apache部署CGI，浏览器访问CGI页面变成下载：httpd.conf 中LoadModule cgid_module modules/mod_cgid.so和LoadModule cgi_module modules/mod_cgi.so取消注释
3. 在部署nginx + fastcgi时遇到"upstream prematurely closed FastCGI stdout while reading response header from upstream"错误：CGI程序中不能使用printf 或 std::cout 使用fcgi_stdio提供的FCGI_printf函数


nullprt代替NULL 定义空指针
=default适用于默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符且无默认参数 =delete用于显式禁用某个函数
使用<thread.h>多线程时，编译时需要连接pthread库

## 侯捷
类被实例化后数据部分可以有很多份，但是函数部分只有一份

class 经典分类：

带指针：complex

不带指针：string

头文件需要防卫式声明防止多次include

inline内联函数（由编译器决定）：

函数定义在class本体中或者用inline关键字定义在本体外

访问级别：public、private、protected：data尽量使用private，只是class 内部使用使用private，需要供外部调用使用public

构造函数：函数名与类名相同，没有返回类型，可以使用初始化列表，可以被重载

函数参数都可以设置默认值

函数重载的本质依旧是不同的函数名称只不过是编译器来生成的不同名称 函数不能同时重载一个空参数的函数和一个有参数但每个参数都有默认值的函数

Singleton 单例模式

**const写在函数参数之后 表示 该函数不改变类的数据，在一个函数不会改变值的情况下需要用const修饰**

友元函数 friend 关键字，可以直接获取类的私有成员

相同的类生成的各个对象互为友元

**性能考虑：**

**参数传递/返回：值传递，引用传递：**

- **尽量使用引用传递，引用返回，如果不希望改变传递的引用，可以使用const修饰引用**
- **不能返回函数内部创建变量的引用，函数结束会释放函数内创建的变量**