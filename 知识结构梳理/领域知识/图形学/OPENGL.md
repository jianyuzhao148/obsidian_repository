OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做标准化设备坐标(Normalized Device Coordinates)，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。

**向量(Vector)**

在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过`vec.x`、`vec.y`、`vec.z`和`vec.w`来获取。注意`vec.w`分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective Division)上。我们会在后面的教程中更详细地讨论向量。

glGenBuffers 第一个参数是指生成的缓冲区数量，如果填入1则需要用unsigned int去接收，>1则需要unsigned int数组

Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！

MVP概述：

为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵

我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束

局部坐标：所有顶点所在的坐标

局部坐标转世界坐标通过模型矩阵===》MVP中的M

世界坐标：我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标

世界坐标转观察坐标通过观察矩阵===》MVP中的V

观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成

MVP

四维齐次坐标系

齐次坐标w

计算物体在光照下的颜色使用 物体本身颜色和环境光颜色进行点乘

opengl深度测试需要配合glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

顶点不代表坐标，坐标是顶点的一部分，是顶点的其中一个属性，顶点还可以有其他属性：纹理，颜色，法线，切线等等。

顶点着色器：会获取我们每一个想要渲染的顶点的调用，有三个顶点就会被调用三次

片段着色器（像素着色器）：渲染每个像素都会调用，会为每个像素运行一次去光栅化，基本目的就是决定像素的颜色是什么

性能点：关键操作不放在片段着色器中，调用次数太过庞大

索引缓冲区：重用现有顶点

错误处理：

- opengl1.1开始自带的方法：glGetError(基于轮询)
- opengl4.3后新增方法：glDebugMessagesCallback(基于回调)

统一变量：将cpu变量直接传递给cpu（c++→shader),统一变量是设置每次绘制的

顶点数组和顶点缓冲区

顶点数组是opengl特有dx中并没有

opengl兼容性配置文件为我们创建了一个顶点数组对象，但是核心配置文件不会，所以需要自行创建